Cherry-picked from
39bb568063683fe91545228c344a8ca696673e3f https://chromium-review.googlesource.com/c/chromium/src/+/1995398
6699523760f5ab5a9adbbbd6d31b43fa5cc508b3 https://chromium-review.googlesource.com/c/chromium/src/+/1995335
fd3dd4a350fa4c2c18b0e9a0c4357db58b07b0b4 https://chromium-review.googlesource.com/c/chromium/src/+/1994882
b1293a58e33b9688fa59a4ace613436a49539e53 https://chromium-review.googlesource.com/c/chromium/src/+/2031112
bf928f02d8d305be0bb265fba25129739aefbe99 https://chromium-review.googlesource.com/c/chromium/src/+/2033508
09934eb176051c9b613893b6f9508c9777471b96 https://chromium-review.googlesource.com/c/chromium/src/+/2046130
db8ecb4af9b2c0d59f994c607bf6d73ed055c93b https://chromium-review.googlesource.com/c/chromium/src/+/2044078
ea16dd4b47a452627dd1591b1d5da2eb23893c79 https://chromium-review.googlesource.com/c/chromium/src/+/2046170
4e5d6372ac331f675ac345c3220155a2a08db832 https://chromium-review.googlesource.com/c/chromium/src/+/2043880
61d7675336030538717eb4792e26b7293d9175cd https://chromium-review.googlesource.com/c/chromium/src/+/2044080
d3aed03810150f0ef2ca6133f3157045e9a9361a https://chromium-review.googlesource.com/c/chromium/src/+/2050376
81ba7a1a09b52106beb153622aa38d9590bbf325 https://chromium-review.googlesource.com/c/chromium/src/+/2081812

With extra changes on
- struct.constants and interface.constants. Upstream missed constants when
  adding list() for map().
- field.ordinal or 0. Upstream patch using field.ordinal or "" to solve
  comparing None and None in py3, but ordinal is number not string, and can
  raise Exception to compare int and str.

diff --git a/mojo/public/tools/bindings/generate_type_mappings.py b/mojo/public/tools/bindings/generate_type_mappings.py
index d6796afb8..ee55e9940 100755
--- a/mojo/public/tools/bindings/generate_type_mappings.py
+++ b/mojo/public/tools/bindings/generate_type_mappings.py
@@ -149,7 +149,7 @@ def main():
   for path in params.dependency:
     typemaps.update(ReadTypemap(path))
 
-  WriteFile(json.dumps({'c++': typemaps}, indent=2).encode(), params.output)
+  WriteFile(json.dumps({'c++': typemaps}, indent=2), params.output)
 
 
 if __name__ == '__main__':
diff --git a/mojo/public/tools/bindings/generators/mojom_cpp_generator.py b/mojo/public/tools/bindings/generators/mojom_cpp_generator.py
index fb6e0827b..89c4a7513 100644
--- a/mojo/public/tools/bindings/generators/mojom_cpp_generator.py
+++ b/mojo/public/tools/bindings/generators/mojom_cpp_generator.py
@@ -840,7 +840,8 @@ class Generator(generator.Generator):
       if param_counts[-1] != version.num_fields:
         param_counts.append(version.num_fields)
 
-    ordinal_fields = sorted(struct.fields, key=lambda field: field.ordinal)
+    ordinal_fields = sorted(
+        struct.fields, key=lambda field: field.ordinal or 0)
     return (StructConstructor(struct.fields, ordinal_fields[:param_count])
             for param_count in param_counts)
 
diff --git a/mojo/public/tools/bindings/generators/mojom_js_generator.py b/mojo/public/tools/bindings/generators/mojom_js_generator.py
index eb8d3b6f4..0ca5d4388 100644
--- a/mojo/public/tools/bindings/generators/mojom_js_generator.py
+++ b/mojo/public/tools/bindings/generators/mojom_js_generator.py
@@ -8,9 +8,14 @@ import mojom.generate.generator as generator
 import mojom.generate.module as mojom
 import mojom.generate.pack as pack
 import os
-import urllib
+import sys
 from mojom.generate.template_expander import UseJinja
 
+if sys.version_info.major == 2:
+  import urllib as urllib_request
+else:
+  import urllib.request as urllib_request
+
 _kind_to_javascript_default_value = {
   mojom.BOOL:                  "false",
   mojom.INT8:                  "0",
@@ -215,7 +220,7 @@ def GetArrayExpectedDimensionSizes(kind):
 
 
 def GetRelativeUrl(module, base_module):
-  return urllib.pathname2url(
+  return urllib_request.pathname2url(
       os.path.relpath(module.path, os.path.dirname(base_module.path)))
 
 
diff --git a/mojo/public/tools/bindings/mojom_bindings_generator.py b/mojo/public/tools/bindings/mojom_bindings_generator.py
index d8a2118eb..de5e018a7 100755
--- a/mojo/public/tools/bindings/mojom_bindings_generator.py
+++ b/mojo/public/tools/bindings/mojom_bindings_generator.py
@@ -123,8 +123,8 @@ def ScrambleMethodOrdinals(interfaces, salt):
         # to guess the results without the secret salt, in order to make it
         # harder for a compromised process to send fake Mojo messages.
         sha256 = hashlib.sha256(salt)
-        sha256.update(interface.mojom_name)
-        sha256.update(str(i))
+        sha256.update(interface.mojom_name.encode('utf-8'))
+        sha256.update(str(i).encode('utf-8'))
         # Take the first 4 bytes as a little-endian uint32.
         ordinal = struct.unpack('<L', sha256.digest()[:4])[0]
         # Trim to 31 bits, so it always fits into a Java (signed) int.
@@ -202,7 +202,7 @@ class MojomProcessor(object):
     module = translate.OrderedModule(tree, module_path, imports)
 
     if args.scrambled_message_id_salt_paths:
-      salt = ''.join(
+      salt = b''.join(
           map(ReadFileContents, args.scrambled_message_id_salt_paths))
       ScrambleMethodOrdinals(module.interfaces, salt)
 
@@ -389,7 +389,7 @@ def _VerifyImportDeps(args, __):
     source_filename, _ = os.path.splitext(rel_path.relative_path())
     output_file = source_filename + '.v'
     output_file_path = os.path.join(args.gen_dir, output_file)
-    WriteFile(b"", output_file_path)
+    WriteFile("", output_file_path)
 
   return 0
 
diff --git a/mojo/public/tools/bindings/pylib/mojom/generate/generator.py b/mojo/public/tools/bindings/pylib/mojom/generate/generator.py
index 6487635ed..1966aaf0d 100644
--- a/mojo/public/tools/bindings/pylib/mojom/generate/generator.py
+++ b/mojo/public/tools/bindings/pylib/mojom/generate/generator.py
@@ -84,7 +84,10 @@ def WriteFile(contents, full_path):
 
   # Dump the data to disk.
   with open(full_path, "wb") as f:
-    f.write(contents)
+    if type(contents) != bytes:
+      f.write(contents.encode('utf-8'))
+    else:
+      f.write(contents)
 
 
 def AddComputedData(module):
diff --git a/mojo/public/tools/bindings/pylib/mojom/generate/module.py b/mojo/public/tools/bindings/pylib/mojom/generate/module.py
index 5c6cf45d1..9896dde05 100644
--- a/mojo/public/tools/bindings/pylib/mojom/generate/module.py
+++ b/mojo/public/tools/bindings/pylib/mojom/generate/module.py
@@ -154,7 +154,10 @@ class ReferenceKind(Kind):
          print(b.name)  # Outputs 'test_struct_2'.
     """
     def Get(self):
-      return self.shared_definition[name]
+      try:
+        return self.shared_definition[name]
+      except KeyError:  # Must raise AttributeError if property doesn't exist.
+        raise AttributeError
 
     def Set(self, value):
       self.shared_definition[name] = value
diff --git a/mojo/public/tools/bindings/pylib/mojom/generate/translate.py b/mojo/public/tools/bindings/pylib/mojom/generate/translate.py
index 16d643e35..837a3dea4 100644
--- a/mojo/public/tools/bindings/pylib/mojom/generate/translate.py
+++ b/mojo/public/tools/bindings/pylib/mojom/generate/translate.py
@@ -277,12 +277,14 @@ def _Struct(module, parsed_struct):
     struct.constants = []
     struct.fields_data = []
   else:
-    struct.enums = map(
-        lambda enum: _Enum(module, enum, struct),
-        _ElemsOfType(parsed_struct.body, ast.Enum, parsed_struct.mojom_name))
-    struct.constants = map(
+    struct.enums = list(
+        map(
+            lambda enum: _Enum(module, enum, struct),
+            _ElemsOfType(parsed_struct.body, ast.Enum,
+                         parsed_struct.mojom_name)))
+    struct.constants = list(map(
         lambda constant: _Constant(module, constant, struct),
-        _ElemsOfType(parsed_struct.body, ast.Const, parsed_struct.mojom_name))
+        _ElemsOfType(parsed_struct.body, ast.Const, parsed_struct.mojom_name)))
     # Stash fields parsed_struct here temporarily.
     struct.fields_data = _ElemsOfType(
         parsed_struct.body, ast.StructField, parsed_struct.mojom_name)
@@ -396,13 +398,13 @@ def _Method(module, parsed_method, interface):
   method = mojom.Method(
       interface, parsed_method.mojom_name,
       ordinal=parsed_method.ordinal.value if parsed_method.ordinal else None)
-  method.parameters = map(
-      lambda parameter: _Parameter(module, parameter, interface),
-      parsed_method.parameter_list)
+  method.parameters = list(
+      map(lambda parameter: _Parameter(module, parameter, interface),
+          parsed_method.parameter_list))
   if parsed_method.response_parameter_list is not None:
-    method.response_parameters = map(
-        lambda parameter: _Parameter(module, parameter, interface),
-                          parsed_method.response_parameter_list)
+    method.response_parameters = list(
+        map(lambda parameter: _Parameter(module, parameter, interface),
+            parsed_method.response_parameter_list))
   method.attributes = _AttributeListToDict(parsed_method.attribute_list)
 
   # Enforce that only methods with response can have a [Sync] attribute.
@@ -427,12 +429,12 @@ def _Interface(module, parsed_iface):
   interface.mojom_name = parsed_iface.mojom_name
   interface.spec = 'x:' + module.mojom_namespace + '.' + interface.mojom_name
   module.kinds[interface.spec] = interface
-  interface.enums = map(
-      lambda enum: _Enum(module, enum, interface),
-      _ElemsOfType(parsed_iface.body, ast.Enum, parsed_iface.mojom_name))
-  interface.constants = map(
+  interface.enums = list(
+      map(lambda enum: _Enum(module, enum, interface),
+          _ElemsOfType(parsed_iface.body, ast.Enum, parsed_iface.mojom_name)))
+  interface.constants = list(map(
       lambda constant: _Constant(module, constant, interface),
-      _ElemsOfType(parsed_iface.body, ast.Const, parsed_iface.mojom_name))
+      _ElemsOfType(parsed_iface.body, ast.Const, parsed_iface.mojom_name)))
   # Stash methods parsed_iface here temporarily.
   interface.methods_data = _ElemsOfType(
       parsed_iface.body, ast.Method, parsed_iface.mojom_name)
@@ -526,9 +528,9 @@ def _Enum(module, parsed_enum, parent_kind):
   enum.parent_kind = parent_kind
   enum.attributes = _AttributeListToDict(parsed_enum.attribute_list)
   if not enum.native_only:
-    enum.fields = map(
-        lambda field: _EnumField(module, enum, field, parent_kind),
-        parsed_enum.enum_value_list)
+    enum.fields = list(
+        map(lambda field: _EnumField(module, enum, field, parent_kind),
+            parsed_enum.enum_value_list))
     enum.min_value, enum.max_value = _ResolveNumericEnumValues(enum.fields)
 
   module.kinds[enum.spec] = enum
@@ -653,40 +655,42 @@ def _Module(tree, path, imports):
 
   filename = os.path.basename(path)
   # First pass collects kinds.
-  module.enums = map(
-      lambda enum: _Enum(module, enum, None),
-      _ElemsOfType(tree.definition_list, ast.Enum, filename))
-  module.structs = map(
-      lambda struct: _Struct(module, struct),
-      _ElemsOfType(tree.definition_list, ast.Struct, filename))
-  module.unions = map(
-      lambda union: _Union(module, union),
-      _ElemsOfType(tree.definition_list, ast.Union, filename))
-  module.interfaces = map(
-      lambda interface: _Interface(module, interface),
-      _ElemsOfType(tree.definition_list, ast.Interface, filename))
-  module.constants = map(
-      lambda constant: _Constant(module, constant, None),
-      _ElemsOfType(tree.definition_list, ast.Const, filename))
+  module.enums = list(
+      map(lambda enum: _Enum(module, enum, None),
+          _ElemsOfType(tree.definition_list, ast.Enum, filename)))
+  module.structs = list(
+      map(lambda struct: _Struct(module, struct),
+          _ElemsOfType(tree.definition_list, ast.Struct, filename)))
+  module.unions = list(
+      map(lambda union: _Union(module, union),
+          _ElemsOfType(tree.definition_list, ast.Union, filename)))
+  module.interfaces = list(
+      map(lambda interface: _Interface(module, interface),
+          _ElemsOfType(tree.definition_list, ast.Interface, filename)))
+  module.constants = list(
+      map(lambda constant: _Constant(module, constant, None),
+          _ElemsOfType(tree.definition_list, ast.Const, filename)))
 
   # Second pass expands fields and methods. This allows fields and parameters
   # to refer to kinds defined anywhere in the mojom.
   all_defined_kinds = {}
   for struct in module.structs:
-    struct.fields = map(lambda field:
-        _StructField(module, field, struct), struct.fields_data)
+    struct.fields = list(
+        map(lambda field: _StructField(module, field, struct),
+            struct.fields_data))
     del struct.fields_data
     all_defined_kinds[struct.spec] = struct
     for enum in struct.enums:
       all_defined_kinds[enum.spec] = enum
   for union in module.unions:
-    union.fields = map(lambda field:
-        _UnionField(module, field, union), union.fields_data)
+    union.fields = list(
+        map(lambda field: _UnionField(module, field, union), union.fields_data))
     del union.fields_data
     all_defined_kinds[union.spec] = union
   for interface in module.interfaces:
-    interface.methods = map(lambda method:
-        _Method(module, method, interface), interface.methods_data)
+    interface.methods = list(
+        map(lambda method: _Method(module, method, interface),
+            interface.methods_data))
     del interface.methods_data
     all_defined_kinds[interface.spec] = interface
     for enum in interface.enums:
