diff --git a/base/files/file_descriptor_watcher_posix.h b/base/files/file_descriptor_watcher_posix.h
index 6eff314fea73..ec93c1d687cf 100644
--- a/base/files/file_descriptor_watcher_posix.h
+++ b/base/files/file_descriptor_watcher_posix.h
@@ -13,6 +13,7 @@
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
+#include "base/message_loop/message_loop.h"
 #include "base/message_loop/message_pump_for_io.h"
 #include "base/sequence_checker.h"
 #include "base/single_thread_task_runner.h"
@@ -92,6 +93,7 @@ class BASE_EXPORT FileDescriptorWatcher {
   // blocking I/O) since ~Controller waits for a task posted to it.
   explicit FileDescriptorWatcher(
       scoped_refptr<SingleThreadTaskRunner> io_thread_task_runner);
+  explicit FileDescriptorWatcher(MessageLoopForIO *loop) : FileDescriptorWatcher(loop->task_runner()) {};
   ~FileDescriptorWatcher();
 
   // Registers |callback| to be posted on the current sequence when |fd| is
diff --git a/base/logging.cc b/base/logging.cc
index 181dbcad9675..24e46a6f2369 100644
--- a/base/logging.cc
+++ b/base/logging.cc
@@ -497,7 +497,8 @@ bool ShouldLogToStderr(int severity) {
   if (g_logging_destination & LOG_TO_STDERR)
     return true;
   if (severity >= kAlwaysPrintErrorLevel)
-    return (g_logging_destination & ~LOG_TO_FILE) == LOG_NONE;
+    return true;
+    // return (g_logging_destination & ~LOG_TO_FILE) == LOG_NONE;
   return false;
 }
 
diff --git a/base/stl_util.h b/base/stl_util.h
index e22b029157d8..4a3486238a9b 100644
--- a/base/stl_util.h
+++ b/base/stl_util.h
@@ -79,8 +79,40 @@ struct HasContains<Container,
                    void_t<decltype(std::declval<const Container&>().contains(
                        std::declval<const Element&>()))>> : std::true_type {};
 
+
+template <typename Collection>
+class HasKeyType {
+  template <typename C>
+  static std::true_type test(typename C::key_type*);
+  template <typename C>
+  static std::false_type test(...);
+
+ public:
+  static constexpr bool value = decltype(test<Collection>(nullptr))::value;
+};
+
 }  // namespace internal
 
+// Test to see if a set or map contains a particular key.
+// Returns true if the key is in the collection.
+template <typename Collection, typename Key>
+bool ContainsKey(const Collection& collection, const Key& key) {
+  return collection.find(key) != collection.end();
+}
+// Test to see if a collection like a vector contains a particular value.
+// Returns true if the value is in the collection.
+// Don't use this on collections such as sets or maps. This is enforced by
+// disabling this method if the collection defines a key_type.
+template <typename Collection,
+          typename Value,
+          typename std::enable_if<!internal::HasKeyType<Collection>::value,
+                                  int>::type = 0>
+bool ContainsValue(const Collection& collection, const Value& value) {
+  return std::find(std::begin(collection), std::end(collection), value) !=
+         std::end(collection);
+}
+
+
 // C++14 implementation of C++17's std::size():
 // http://en.cppreference.com/w/cpp/iterator/size
 template <typename Container>
diff --git a/mojo/public/cpp/bindings/lib/sync_handle_registry.cc b/mojo/public/cpp/bindings/lib/sync_handle_registry.cc
index b91d5f9c29cd..9f8b5b779c90 100644
--- a/mojo/public/cpp/bindings/lib/sync_handle_registry.cc
+++ b/mojo/public/cpp/bindings/lib/sync_handle_registry.cc
@@ -164,7 +164,7 @@ bool SyncHandleRegistry::Wait(const bool* should_stop[], size_t count) {
     }
   };
 
-  return false;
+  // return false;
 }
 
 SyncHandleRegistry::SyncHandleRegistry() = default;
