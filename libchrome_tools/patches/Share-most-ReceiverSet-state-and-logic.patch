From 23745d8d3fb85f50781b718f871ed400b9128706 Mon Sep 17 00:00:00 2001
From: Ken Rockot <rockot@google.com>
Date: Wed, 24 Mar 2021 12:29:50 -0700
Subject: [PATCH 1/2] Share most ReceiverSet state and logic

ReceiverSet has grown into a widely used template, with most of the
state and logic being redundant across each specialization. This
introduces a shared ReceiverSetState class to encapsulate all the common
bits.

Bug: None
Change-Id: I9587373db2cb13b696faf160807abd36e3d0fdb5
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/2782751
Reviewed-by: Robert Sesek <rsesek@chromium.org>
Commit-Queue: Ken Rockot <rockot@google.com>
Cr-Commit-Position: refs/heads/master@{#866231}

CrOS-Libchrome-Original-Commit: 3ac1814d45baaec54296116fa7c10e089cb354ac
Change-Id: I6642c96c1fdd4aced21047714f9d4f3a31cbe74c
---
 BUILD.gn                                 |   1 +
 mojo/public/cpp/bindings/receiver_set.cc | 146 ++++++++++++
 mojo/public/cpp/bindings/receiver_set.h  | 269 +++++++++++------------
 3 files changed, 273 insertions(+), 143 deletions(-)
 create mode 100644 mojo/public/cpp/bindings/receiver_set.cc

diff --git a/BUILD.gn b/BUILD.gn
index 0e3ee842a..4197a22da 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -877,6 +877,7 @@ if (use.mojo) {
           "mojo/public/cpp/bindings/lib/validation_errors.cc",
           "mojo/public/cpp/bindings/lib/validation_util.cc",
           "mojo/public/cpp/bindings/pending_flush.cc",
+          "mojo/public/cpp/bindings/receiver_set.cc",
           "mojo/public/cpp/platform/named_platform_channel.cc",
           "mojo/public/cpp/platform/named_platform_channel_posix.cc",
           "mojo/public/cpp/platform/platform_channel.cc",
diff --git a/mojo/public/cpp/bindings/receiver_set.cc b/mojo/public/cpp/bindings/receiver_set.cc
new file mode 100644
index 000000000..bd764bea0
--- /dev/null
+++ b/mojo/public/cpp/bindings/receiver_set.cc
@@ -0,0 +1,146 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "mojo/public/cpp/bindings/receiver_set.h"
+
+#include <string>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/callback.h"
+#include "base/check.h"
+#include "base/memory/weak_ptr.h"
+#include "mojo/public/cpp/bindings/message.h"
+
+namespace mojo {
+
+class ReceiverSetState::Entry::DispatchFilter : public MessageFilter {
+ public:
+  explicit DispatchFilter(Entry& entry) : entry_(entry) {}
+  DispatchFilter(const DispatchFilter&) = delete;
+  DispatchFilter& operator=(const DispatchFilter&) = delete;
+  ~DispatchFilter() override = default;
+
+ private:
+  // MessageFilter:
+  bool WillDispatch(Message* message) override {
+    entry_.WillDispatch();
+    return true;
+  }
+
+  void DidDispatchOrReject(Message* message, bool accepted) override {}
+
+  Entry& entry_;
+};
+
+ReceiverSetState::Entry::Entry(ReceiverSetState& state,
+                               ReceiverId id,
+                               std::unique_ptr<ReceiverState> receiver)
+    : state_(state), id_(id), receiver_(std::move(receiver)) {
+  receiver_->InstallDispatchHooks(
+      std::make_unique<DispatchFilter>(*this),
+      base::BindRepeating(&ReceiverSetState::Entry::OnDisconnect,
+                          base::Unretained(this)));
+}
+
+ReceiverSetState::Entry::~Entry() = default;
+
+void ReceiverSetState::Entry::WillDispatch() {
+  state_.SetDispatchContext(receiver_->GetContext(), id_);
+}
+
+void ReceiverSetState::Entry::OnDisconnect(uint32_t custom_reason_code,
+                                           const std::string& description) {
+  WillDispatch();
+  state_.OnDisconnect(id_, custom_reason_code, description);
+}
+
+ReceiverSetState::ReceiverSetState() = default;
+
+ReceiverSetState::~ReceiverSetState() = default;
+
+void ReceiverSetState::set_disconnect_handler(base::RepeatingClosure handler) {
+  disconnect_handler_ = std::move(handler);
+  disconnect_with_reason_handler_.Reset();
+}
+
+void ReceiverSetState::set_disconnect_with_reason_handler(
+    RepeatingConnectionErrorWithReasonCallback handler) {
+  disconnect_with_reason_handler_ = std::move(handler);
+  disconnect_handler_.Reset();
+}
+
+ReportBadMessageCallback ReceiverSetState::GetBadMessageCallback() {
+  DCHECK(current_context_);
+  return base::BindOnce(
+      [](ReportBadMessageCallback error_callback,
+         base::WeakPtr<ReceiverSetState> receiver_set, ReceiverId receiver_id,
+         const std::string& error) {
+        std::move(error_callback).Run(error);
+        if (receiver_set)
+          receiver_set->Remove(receiver_id);
+      },
+      mojo::GetBadMessageCallback(), weak_ptr_factory_.GetWeakPtr(),
+      current_receiver());
+}
+
+ReceiverId ReceiverSetState::Add(std::unique_ptr<ReceiverState> receiver) {
+  ReceiverId id = next_receiver_id_++;
+  auto result = entries_.emplace(
+      id, std::make_unique<Entry>(*this, id, std::move(receiver)));
+  CHECK(result.second) << "ReceiverId overflow with collision";
+  return id;
+}
+
+bool ReceiverSetState::Remove(ReceiverId id) {
+  auto it = entries_.find(id);
+  if (it == entries_.end())
+    return false;
+  entries_.erase(it);
+  return true;
+}
+
+void ReceiverSetState::FlushForTesting() {
+  // We avoid flushing while iterating over |entries_| because this set may be
+  // mutated during individual flush operations.  Instead, snapshot the
+  // ReceiverIds first, then iterate over them. This is less efficient, but it's
+  // only a testing API. This also allows for correct behavior in reentrant
+  // calls to FlushForTesting().
+  std::vector<ReceiverId> ids;
+  for (const auto& entry : entries_)
+    ids.push_back(entry.first);
+
+  auto weak_self = weak_ptr_factory_.GetWeakPtr();
+  for (const auto& id : ids) {
+    if (!weak_self)
+      return;
+    auto it = entries_.find(id);
+    if (it != entries_.end())
+      it->second->receiver().FlushForTesting();
+  }
+}
+
+void ReceiverSetState::SetDispatchContext(const void* context,
+                                          ReceiverId receiver_id) {
+  current_context_ = context;
+  current_receiver_ = receiver_id;
+}
+
+void ReceiverSetState::OnDisconnect(ReceiverId id,
+                                    uint32_t custom_reason_code,
+                                    const std::string& description) {
+  auto it = entries_.find(id);
+  DCHECK(it != entries_.end());
+
+  // We keep the Entry alive throughout error dispatch.
+  std::unique_ptr<Entry> entry = std::move(it->second);
+  entries_.erase(it);
+
+  if (disconnect_handler_)
+    disconnect_handler_.Run();
+  else if (disconnect_with_reason_handler_)
+    disconnect_with_reason_handler_.Run(custom_reason_code, description);
+}
+
+}  // namespace mojo
diff --git a/mojo/public/cpp/bindings/receiver_set.h b/mojo/public/cpp/bindings/receiver_set.h
index 97049ab14..ca06a766b 100644
--- a/mojo/public/cpp/bindings/receiver_set.h
+++ b/mojo/public/cpp/bindings/receiver_set.h
@@ -12,6 +12,7 @@
 
 #include "base/bind.h"
 #include "base/callback.h"
+#include "base/component_export.h"
 #include "base/macros.h"
 #include "base/memory/ptr_util.h"
 #include "base/stl_util.h"
@@ -53,6 +54,83 @@ struct ReceiverSetContextTraits<void> {
   static constexpr bool SupportsContext() { return false; }
 };
 
+// Shared base class owning specific type-agnostic ReceiverSet state and logic.
+class COMPONENT_EXPORT(MOJO_CPP_BINDINGS) ReceiverSetState {
+ public:
+  class ReceiverState {
+   public:
+    virtual ~ReceiverState() = default;
+    virtual const void* GetContext() const = 0;
+    virtual void InstallDispatchHooks(
+        std::unique_ptr<MessageFilter> filter,
+        RepeatingConnectionErrorWithReasonCallback disconnect_handler) = 0;
+    virtual void FlushForTesting() = 0;
+  };
+
+  class COMPONENT_EXPORT(MOJO_CPP_BINDINGS) Entry {
+   public:
+    Entry(ReceiverSetState& state,
+          ReceiverId id,
+          std::unique_ptr<ReceiverState> receiver);
+    ~Entry();
+
+    ReceiverState& receiver() { return *receiver_; }
+
+   private:
+    class DispatchFilter;
+
+    void WillDispatch();
+    void OnDisconnect(uint32_t custom_reason_code,
+                      const std::string& description);
+
+    ReceiverSetState& state_;
+    const ReceiverId id_;
+    const std::unique_ptr<ReceiverState> receiver_;
+  };
+
+  using EntryMap = std::map<ReceiverId, std::unique_ptr<Entry>>;
+
+  ReceiverSetState();
+  ReceiverSetState(const ReceiverSetState&) = delete;
+  ReceiverSetState& operator=(const ReceiverSetState&) = delete;
+  ~ReceiverSetState();
+
+  EntryMap& entries() { return entries_; }
+  const EntryMap& entries() const { return entries_; }
+
+  const void* current_context() const {
+    DCHECK(current_context_);
+    return current_context_;
+  }
+
+  ReceiverId current_receiver() const {
+    DCHECK(current_context_);
+    return current_receiver_;
+  }
+
+  void set_disconnect_handler(base::RepeatingClosure handler);
+  void set_disconnect_with_reason_handler(
+      RepeatingConnectionErrorWithReasonCallback handler);
+
+  ReportBadMessageCallback GetBadMessageCallback();
+  ReceiverId Add(std::unique_ptr<ReceiverState> receiver);
+  bool Remove(ReceiverId id);
+  void FlushForTesting();
+  void SetDispatchContext(const void* context, ReceiverId receiver_id);
+  void OnDisconnect(ReceiverId id,
+                    uint32_t custom_reason_code,
+                    const std::string& description);
+
+ private:
+  base::RepeatingClosure disconnect_handler_;
+  RepeatingConnectionErrorWithReasonCallback disconnect_with_reason_handler_;
+  ReceiverId next_receiver_id_ = 0;
+  EntryMap entries_;
+  const void* current_context_ = nullptr;
+  ReceiverId current_receiver_;
+  base::WeakPtrFactory<ReceiverSetState> weak_ptr_factory_{this};
+};
+
 // Generic helper used to own a collection of Receiver endpoints. For
 // convenience this type automatically manages cleanup of receivers that have
 // been disconnected from their remote caller.
@@ -96,6 +174,8 @@ class ReceiverSetBase {
   using PreDispatchCallback = base::RepeatingCallback<void(const Context&)>;
 
   ReceiverSetBase() = default;
+  ReceiverSetBase(const ReceiverSetBase&) = delete;
+  ReceiverSetBase& operator=(const ReceiverSetBase&) = delete;
 
   // Sets a callback to be invoked any time a receiver in the set is
   // disconnected. The callback is invoked *after* the receiver in question
@@ -103,15 +183,13 @@ class ReceiverSetBase {
   // disconnected receiver's context value during the callback if the
   // ContextType is not void.
   void set_disconnect_handler(base::RepeatingClosure handler) {
-    disconnect_handler_ = std::move(handler);
-    disconnect_with_reason_handler_.Reset();
+    state_.set_disconnect_handler(std::move(handler));
   }
 
   // Like above but also provides the reason given for disconnection, if any.
   void set_disconnect_with_reason_handler(
       RepeatingConnectionErrorWithReasonCallback handler) {
-    disconnect_with_reason_handler_ = std::move(handler);
-    disconnect_handler_.Reset();
+    state_.set_disconnect_with_reason_handler(std::move(handler));
   }
 
   // Adds a new receiver to the set, binding |receiver| to |impl| with no
@@ -152,39 +230,36 @@ class ReceiverSetBase {
   // A removed receiver is effectively closed and its remote (if any) will be
   // disconnected. No further messages or disconnection notifications will be
   // scheduled or executed for the removed receiver.
-  bool Remove(ReceiverId id) {
-    auto it = receivers_.find(id);
-    if (it == receivers_.end())
-      return false;
-    receivers_.erase(it);
-    return true;
-  }
+  bool Remove(ReceiverId id) { return state_.Remove(id); }
 
   // Unbinds and takes all receivers in this set.
   std::vector<PendingType> TakeReceivers() {
+    ReceiverSetState::EntryMap entries;
+    std::swap(state_.entries(), entries);
     std::vector<PendingType> pending_receivers;
-    for (auto& it : receivers_) {
-      pending_receivers.push_back(it.second->Unbind());
+    for (auto& entry : entries) {
+      ReceiverEntry& receiver =
+          static_cast<ReceiverEntry&>(entry.second->receiver());
+      pending_receivers.push_back(receiver.Unbind());
     }
-    receivers_.clear();
     return pending_receivers;
   }
 
   // Removes all receivers from the set, effectively closing all of them. This
   // ReceiverSet will not schedule or execute any further method invocations or
   // disconnection notifications until a new receiver is added to the set.
-  void Clear() { receivers_.clear(); }
+  void Clear() { state_.entries().clear(); }
 
   // Predicate to test if a receiver exists in the set.
   //
   // Returns |true| if the receiver is in the set and |false| if not.
   bool HasReceiver(ReceiverId id) const {
-    return base::Contains(receivers_, id);
+    return base::Contains(state_.entries(), id);
   }
 
-  bool empty() const { return receivers_.empty(); }
+  bool empty() const { return state_.entries().empty(); }
 
-  size_t size() const { return receivers_.size(); }
+  size_t size() const { return state_.entries().size(); }
 
   // Implementations may call this when processing a received method call or
   // disconnection notification. During the extent of method invocation or
@@ -203,18 +278,14 @@ class ReceiverSetBase {
   const Context& current_context() const {
     static_assert(ContextTraits::SupportsContext(),
                   "current_context() requires non-void context type.");
-    DCHECK(current_context_);
-    return *current_context_;
+    return *static_cast<const Context*>(state_.current_context());
   }
 
   // Implementations may call this when processing a received method call or
   // disconnection notification. See above note for constraints on usage.
   // This returns the ReceiverId associated with the specific receiver which
   // received the incoming method call or disconnection notification.
-  ReceiverId current_receiver() const {
-    DCHECK(current_context_);
-    return current_receiver_;
-  }
+  ReceiverId current_receiver() const { return state_.current_receiver(); }
 
   // Reports the currently dispatching Message as bad and removes the receiver
   // which received it. Note that this is only legal to call from directly
@@ -235,164 +306,76 @@ class ReceiverSetBase {
   // sequence which owns the ReceiverSetBase, and upon invocation it will report
   // the corresponding message as bad.
   ReportBadMessageCallback GetBadMessageCallback() {
-    DCHECK(current_context_);
-    return base::BindOnce(
-        [](ReportBadMessageCallback error_callback,
-           base::WeakPtr<ReceiverSetBase> receiver_set, ReceiverId receiver_id,
-           const std::string& error) {
-          std::move(error_callback).Run(error);
-          if (receiver_set)
-            receiver_set->Remove(receiver_id);
-        },
-        mojo::GetBadMessageCallback(), weak_ptr_factory_.GetWeakPtr(),
-        current_receiver());
+    return state_.GetBadMessageCallback();
   }
 
-  void FlushForTesting() {
-    // We avoid flushing while iterating over |receivers_| because this set
-    // may be mutated during individual flush operations.  Instead, snapshot
-    // the ReceiverIds first, then iterate over them. This is less efficient,
-    // but it's only a testing API. This also allows for correct behavior in
-    // reentrant calls to FlushForTesting().
-    std::vector<ReceiverId> ids;
-    for (const auto& receiver : receivers_)
-      ids.push_back(receiver.first);
-
-    auto weak_self = weak_ptr_factory_.GetWeakPtr();
-    for (const auto& id : ids) {
-      if (!weak_self)
-        return;
-      auto it = receivers_.find(id);
-      if (it != receivers_.end())
-        it->second->FlushForTesting();
-    }
-  }
+  void FlushForTesting() { state_.FlushForTesting(); }
 
   // Swaps the interface implementation with a different one, to allow tests
   // to modify behavior.
   //
   // Returns the existing interface implementation to the caller.
   ImplPointerType SwapImplForTesting(ReceiverId id, ImplPointerType new_impl) {
-    auto it = receivers_.find(id);
-    if (it == receivers_.end())
+    auto it = state_.entries().find(id);
+    if (it == state_.entries().end())
       return nullptr;
 
-    return it->second->SwapImplForTesting(new_impl);
+    ReceiverEntry& entry = static_cast<ReceiverEntry&>(it->second->receiver());
+    return entry.SwapImplForTesting(new_impl);
   }
 
  private:
-  friend class Entry;
+  friend class ReceiverEntry;
 
-  class Entry {
+  class ReceiverEntry : public ReceiverSetState::ReceiverState {
    public:
-    Entry(ImplPointerType impl,
-          PendingType receiver,
-          ReceiverSetBase* receiver_set,
-          ReceiverId receiver_id,
-          Context context,
-          scoped_refptr<base::SequencedTaskRunner> task_runner)
+    ReceiverEntry(ImplPointerType impl,
+                  PendingType receiver,
+                  Context context,
+                  scoped_refptr<base::SequencedTaskRunner> task_runner)
         : receiver_(std::move(impl),
                     std::move(receiver),
                     std::move(task_runner)),
-          receiver_set_(receiver_set),
-          receiver_id_(receiver_id),
-          context_(std::move(context)) {
-      receiver_.SetFilter(std::make_unique<DispatchFilter>(this));
+          context_(std::move(context)) {}
+    ReceiverEntry(const ReceiverEntry&) = delete;
+    ReceiverEntry& operator=(const ReceiverEntry&) = delete;
+    ~ReceiverEntry() override = default;
+
+    // ReceiverSetState::ReceiverState:
+    const void* GetContext() const override { return &context_; }
+
+    void InstallDispatchHooks(std::unique_ptr<MessageFilter> filter,
+                              RepeatingConnectionErrorWithReasonCallback
+                                  disconnect_handler) override {
+      receiver_.SetFilter(std::move(filter));
       receiver_.set_disconnect_with_reason_handler(
-          base::BindOnce(&Entry::OnDisconnect, base::Unretained(this)));
+          std::move(disconnect_handler));
     }
 
+    void FlushForTesting() override { receiver_.FlushForTesting(); }
+
     ImplPointerType SwapImplForTesting(ImplPointerType new_impl) {
       return receiver_.SwapImplForTesting(new_impl);
     }
 
-    void FlushForTesting() { receiver_.FlushForTesting(); }
-
     PendingType Unbind() { return receiver_.Unbind(); }
 
    private:
-    class DispatchFilter : public MessageFilter {
-     public:
-      explicit DispatchFilter(Entry* entry) : entry_(entry) {}
-      ~DispatchFilter() override {}
-
-     private:
-      // MessageFilter:
-      bool WillDispatch(Message* message) override {
-        entry_->WillDispatch();
-        return true;
-      }
-
-      void DidDispatchOrReject(Message* message, bool accepted) override {}
-
-      Entry* entry_;
-
-      DISALLOW_COPY_AND_ASSIGN(DispatchFilter);
-    };
-
-    void WillDispatch() {
-      receiver_set_->SetDispatchContext(&context_, receiver_id_);
-    }
-
-    void OnDisconnect(uint32_t custom_reason_code,
-                      const std::string& description) {
-      WillDispatch();
-      receiver_set_->OnDisconnect(receiver_id_, custom_reason_code,
-                                  description);
-    }
-
     ReceiverType receiver_;
-    ReceiverSetBase* const receiver_set_;
-    const ReceiverId receiver_id_;
     Context const context_;
-
-    DISALLOW_COPY_AND_ASSIGN(Entry);
   };
 
-  void SetDispatchContext(const Context* context, ReceiverId receiver_id) {
-    current_context_ = context;
-    current_receiver_ = receiver_id;
-  }
-
   ReceiverId AddImpl(ImplPointerType impl,
                      PendingType receiver,
                      Context context,
                      scoped_refptr<base::SequencedTaskRunner> task_runner) {
     DCHECK(receiver.is_valid());
-    ReceiverId id = next_receiver_id_++;
-    DCHECK_GE(next_receiver_id_, 0u);
-    auto entry =
-        std::make_unique<Entry>(std::move(impl), std::move(receiver), this, id,
-                                std::move(context), std::move(task_runner));
-    receivers_.insert(std::make_pair(id, std::move(entry)));
-    return id;
+    return state_.Add(std::make_unique<ReceiverEntry>(
+        std::move(impl), std::move(receiver), std::move(context),
+        std::move(task_runner)));
   }
 
-  void OnDisconnect(ReceiverId id,
-                    uint32_t custom_reason_code,
-                    const std::string& description) {
-    auto it = receivers_.find(id);
-    DCHECK(it != receivers_.end());
-
-    // We keep the Entry alive throughout error dispatch.
-    std::unique_ptr<Entry> entry = std::move(it->second);
-    receivers_.erase(it);
-
-    if (disconnect_handler_)
-      disconnect_handler_.Run();
-    else if (disconnect_with_reason_handler_)
-      disconnect_with_reason_handler_.Run(custom_reason_code, description);
-  }
-
-  base::RepeatingClosure disconnect_handler_;
-  RepeatingConnectionErrorWithReasonCallback disconnect_with_reason_handler_;
-  ReceiverId next_receiver_id_ = 0;
-  std::map<ReceiverId, std::unique_ptr<Entry>> receivers_;
-  const Context* current_context_ = nullptr;
-  ReceiverId current_receiver_;
-  base::WeakPtrFactory<ReceiverSetBase> weak_ptr_factory_{this};
-
-  DISALLOW_COPY_AND_ASSIGN(ReceiverSetBase);
+  ReceiverSetState state_;
 };
 
 // Common helper for a set of Receivers which do not own their implementation.
-- 
2.33.0.rc1.237.g0d66db33f3-goog

